// Generated by Haxe 4.1.1
(function ($hx_exports, $global) { "use strict";
$hx_exports["me"] = $hx_exports["me"] || {};
$hx_exports["me"]["cunity"] = $hx_exports["me"]["cunity"] || {};
$hx_exports["me"]["cunity"]["debug"] = $hx_exports["me"]["cunity"]["debug"] || {};
$hx_exports["me"]["cunity"]["debug"]["Out"] = $hx_exports["me"]["cunity"]["debug"]["Out"] || {};
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
function $extend(from, fields) {
	var proto = Object.create(from);
	for (var name in fields) proto[name] = fields[name];
	if( fields.toString !== Object.prototype.toString ) proto.toString = fields.toString;
	return proto;
}
var EReg = function(r,opt) {
	this.r = new RegExp(r,opt.split("u").join(""));
};
EReg.__name__ = "EReg";
EReg.prototype = {
	r: null
	,match: function(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	,__class__: EReg
};
var HxOverrides = function() { };
HxOverrides.__name__ = "HxOverrides";
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
HxOverrides.remove = function(a,obj) {
	var i = a.indexOf(obj);
	if(i == -1) {
		return false;
	}
	a.splice(i,1);
	return true;
};
HxOverrides.now = function() {
	return Date.now();
};
var IntIterator = function(min,max) {
	this.min = min;
	this.max = max;
};
IntIterator.__name__ = "IntIterator";
IntIterator.prototype = {
	min: null
	,max: null
	,__class__: IntIterator
};
var JsxStaticInit_$_$ = function() { };
JsxStaticInit_$_$.__name__ = "JsxStaticInit__";
var Lambda = function() { };
Lambda.__name__ = "Lambda";
Lambda.has = function(it,elt) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(x1 == elt) {
			return true;
		}
	}
	return false;
};
Lambda.exists = function(it,f) {
	var x = $getIterator(it);
	while(x.hasNext()) {
		var x1 = x.next();
		if(f(x1)) {
			return true;
		}
	}
	return false;
};
Math.__name__ = "Math";
var Reflect = function() { };
Reflect.__name__ = "Reflect";
Reflect.field = function(o,field) {
	try {
		return o[field];
	} catch( _g ) {
		return null;
	}
};
Reflect.fields = function(o) {
	var a = [];
	if(o != null) {
		var hasOwnProperty = Object.prototype.hasOwnProperty;
		for( var f in o ) {
		if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
			a.push(f);
		}
		}
	}
	return a;
};
Reflect.isFunction = function(f) {
	if(typeof(f) == "function") {
		return !(f.__name__ || f.__ename__);
	} else {
		return false;
	}
};
Reflect.compareMethods = function(f1,f2) {
	if(f1 == f2) {
		return true;
	}
	if(!Reflect.isFunction(f1) || !Reflect.isFunction(f2)) {
		return false;
	}
	if(f1.scope == f2.scope && f1.method == f2.method) {
		return f1.method != null;
	} else {
		return false;
	}
};
var Std = function() { };
Std.__name__ = "Std";
Std.string = function(s) {
	return js_Boot.__string_rec(s,"");
};
Std.parseInt = function(x) {
	if(x != null) {
		var _g = 0;
		var _g1 = x.length;
		while(_g < _g1) {
			var i = _g++;
			var c = x.charCodeAt(i);
			if(c <= 8 || c >= 14 && c != 32 && c != 45) {
				var nc = x.charCodeAt(i + 1);
				var v = parseInt(x,nc == 120 || nc == 88 ? 16 : 10);
				if(isNaN(v)) {
					return null;
				} else {
					return v;
				}
			}
		}
	}
	return null;
};
var StringBuf = function() {
	this.b = "";
};
StringBuf.__name__ = "StringBuf";
StringBuf.prototype = {
	b: null
	,__class__: StringBuf
};
var StringTools = function() { };
StringTools.__name__ = "StringTools";
StringTools.isSpace = function(s,pos) {
	var c = HxOverrides.cca(s,pos);
	if(!(c > 8 && c < 14)) {
		return c == 32;
	} else {
		return true;
	}
};
StringTools.ltrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,r)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,r,l - r);
	} else {
		return s;
	}
};
StringTools.rtrim = function(s) {
	var l = s.length;
	var r = 0;
	while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
	if(r > 0) {
		return HxOverrides.substr(s,0,l - r);
	} else {
		return s;
	}
};
StringTools.trim = function(s) {
	return StringTools.ltrim(StringTools.rtrim(s));
};
var ValueType = $hxEnums["ValueType"] = { __ename__ : true, __constructs__ : ["TNull","TInt","TFloat","TBool","TObject","TFunction","TClass","TEnum","TUnknown"]
	,TNull: {_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_index:8,__enum__:"ValueType",toString:$estr}
};
var Type = function() { };
Type.__name__ = "Type";
Type.getInstanceFields = function(c) {
	var a = [];
	for(var i in c.prototype) a.push(i);
	HxOverrides.remove(a,"__class__");
	HxOverrides.remove(a,"__properties__");
	return a;
};
Type.typeof = function(v) {
	switch(typeof(v)) {
	case "boolean":
		return ValueType.TBool;
	case "function":
		if(v.__name__ || v.__ename__) {
			return ValueType.TObject;
		}
		return ValueType.TFunction;
	case "number":
		if(Math.ceil(v) == v % 2147483648.0) {
			return ValueType.TInt;
		}
		return ValueType.TFloat;
	case "object":
		if(v == null) {
			return ValueType.TNull;
		}
		var e = v.__enum__;
		if(e != null) {
			return ValueType.TEnum($hxEnums[e]);
		}
		var c = js_Boot.getClass(v);
		if(c != null) {
			return ValueType.TClass(c);
		}
		return ValueType.TObject;
	case "string":
		return ValueType.TClass(String);
	case "undefined":
		return ValueType.TNull;
	default:
		return ValueType.TUnknown;
	}
};
var apollo_cache_inmemory_InMemoryCache = require("apollo-cache-inmemory").InMemoryCache;
var apollo_client_ApolloClient = require("apollo-client").ApolloClient;
var apollo_link_http_HttpLink = require("apollo-link-http").createHttpLink;
var graphql_ASTDefs = function() { };
graphql_ASTDefs.__name__ = "graphql.ASTDefs";
var graphql_parser_GeneratedLexer = function(opts) {
	this.lineStart = 0;
	this.line = 1;
	this.options = opts;
	this.advance = $bind(this,this.advanceLexer);
};
graphql_parser_GeneratedLexer.__name__ = "graphql.parser.GeneratedLexer";
graphql_parser_GeneratedLexer.createLexer = function(source,options) {
	var startOfFileToken = graphql_parser_TokUtil.asToken("<SOF>",0,0,0,0,null);
	var lexer = new graphql_parser_GeneratedLexer(options);
	lexer.source = source;
	lexer.lastToken = startOfFileToken;
	lexer.token = startOfFileToken;
	return lexer;
};
graphql_parser_GeneratedLexer.prototype = {
	source: null
	,options: null
	,lastToken: null
	,token: null
	,line: null
	,lineStart: null
	,advance: null
	,advanceLexer: function() {
		this.lastToken = this.token;
		var token = this.token = this.lookahead();
		return token;
	}
	,lookahead: function() {
		var token = this.token;
		if(token.kind != "<EOF>") {
			while(true) {
				token = token.next != null ? token.next : token.next = this.readToken(this,token);
				if(!(token.kind == "Comment")) {
					break;
				}
			}
		}
		return token;
	}
	,printCharCode: function(code) {
		if(code < 127) {
			return JSON.stringify(String.fromCodePoint(code));
		} else {
			return "ESCMAD";
		}
	}
	,readToken: function(lexer,prev) {
		var source = lexer.source;
		var body = source;
		var bodyLength = body.length;
		var pos = this.positionAfterWhitespace(body,prev.end,lexer);
		var line = lexer.line;
		var col = 1 + pos - lexer.lineStart;
		if(pos >= bodyLength) {
			return graphql_parser_TokUtil.asToken("<EOF>",bodyLength,bodyLength,line,col,prev);
		}
		var code = source.string.charCodeAt(pos + source.start);
		if(code < 32 && code != 9 && code != 10 && code != 13) {
			throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,pos,"Cannot contain the invalid character " + this.printCharCode(code) + "."));
		}
		switch(code) {
		case 33:
			return graphql_parser_TokUtil.asToken("!",pos,pos + 1,line,col,prev);
		case 34:
			if(source.string.charCodeAt(pos + 1 + source.start) == 34 && source.string.charCodeAt(pos + 2 + source.start) == 34) {
				return this.readBlockString(source,pos,line,col,prev);
			}
			return this.readString(source,pos,line,col,prev);
		case 35:
			return this.readComment(source,pos,line,col,prev);
		case 36:
			return graphql_parser_TokUtil.asToken("$",pos,pos + 1,line,col,prev);
		case 38:
			return graphql_parser_TokUtil.asToken("&",pos,pos + 1,line,col,prev);
		case 40:
			return graphql_parser_TokUtil.asToken("(",pos,pos + 1,line,col,prev);
		case 41:
			return graphql_parser_TokUtil.asToken(")",pos,pos + 1,line,col,prev);
		case 46:
			if(source.string.charCodeAt(pos + 1 + source.start) == 46 && source.string.charCodeAt(pos + 2 + source.start) == 46) {
				return graphql_parser_TokUtil.asToken("...",pos,pos + 3,line,col,prev);
			}
			break;
		case 45:case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
			return this.readNumber(source,pos,code,line,col,prev);
		case 58:
			return graphql_parser_TokUtil.asToken(":",pos,pos + 1,line,col,prev);
		case 61:
			return graphql_parser_TokUtil.asToken("=",pos,pos + 1,line,col,prev);
		case 64:
			return graphql_parser_TokUtil.asToken("@",pos,pos + 1,line,col,prev);
		case 91:
			return graphql_parser_TokUtil.asToken("[",pos,pos + 1,line,col,prev);
		case 93:
			return graphql_parser_TokUtil.asToken("]",pos,pos + 1,line,col,prev);
		case 65:case 66:case 67:case 68:case 69:case 70:case 71:case 72:case 73:case 74:case 75:case 76:case 77:case 78:case 79:case 80:case 81:case 82:case 83:case 84:case 85:case 86:case 87:case 88:case 89:case 90:case 95:case 97:case 98:case 99:case 100:case 101:case 102:case 103:case 104:case 105:case 106:case 107:case 108:case 109:case 110:case 111:case 112:case 113:case 114:case 115:case 116:case 117:case 118:case 119:case 120:case 121:case 122:
			return this.readName(source,pos,line,col,prev);
		case 123:
			return graphql_parser_TokUtil.asToken("{",pos,pos + 1,line,col,prev);
		case 124:
			return graphql_parser_TokUtil.asToken("|",pos,pos + 1,line,col,prev);
		case 125:
			return graphql_parser_TokUtil.asToken("}",pos,pos + 1,line,col,prev);
		}
		throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,pos,this.unexpectedCharacterMessage(code)));
	}
	,unexpectedCharacterMessage: function(code) {
		if(code == 39) {
			return "Unexpected single quote character ('), did you mean to use " + "a double quote (\")?";
		}
		return "Cannot parse the unexpected character " + this.printCharCode(code) + ".";
	}
	,positionAfterWhitespace: function(body,startPosition,lexer) {
		var bodyLength = body.length;
		var position = startPosition;
		while(position < bodyLength) {
			var this1 = this.source;
			var code = this1.string.charCodeAt(position + this1.start);
			if(code == 9 || code == 32 || code == 44 || code == 65279) {
				++position;
			} else if(code == 10) {
				++position;
				++lexer.line;
				lexer.lineStart = position;
			} else if(code == 13) {
				var this2 = this.source;
				if(this2.string.charCodeAt(position + 1 + this2.start) == 10) {
					position += 2;
				} else {
					++position;
				}
				++lexer.line;
				lexer.lineStart = position;
			} else {
				break;
			}
		}
		return position;
	}
	,readComment: function(source,start,line,col,prev) {
		var body = source;
		var code;
		var position = start;
		while(true) {
			code = source.string.charCodeAt(++position + source.start);
			if(!(code != null && (code > 31 || code == 9))) {
				break;
			}
		}
		var range_min = start + 1;
		var range_max = position;
		return graphql_parser_TokUtil.asToken("Comment",start,position,line,col,prev,graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min) + body.start,graphql_parser_StringSlice.clamp(body,range_max) + body.start).toString());
	}
	,readNumber: function(source,start,firstCode,line,col,prev) {
		var body = source;
		var code = firstCode;
		var position = start;
		var isFloat = false;
		if(code == 45) {
			code = source.string.charCodeAt(++position + source.start);
		}
		if(code == 48) {
			code = source.string.charCodeAt(++position + source.start);
			if(code >= 48 && code <= 57) {
				throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,position,"Invalid number, unexpected digit after 0: " + this.printCharCode(code) + "."));
			}
		} else {
			position = this.readDigits(source,position,code);
			code = source.string.charCodeAt(position + source.start);
		}
		if(code == 46) {
			isFloat = true;
			code = source.string.charCodeAt(++position + source.start);
			position = this.readDigits(source,position,code);
			code = source.string.charCodeAt(position + source.start);
		}
		if(code == 69 || code == 101) {
			isFloat = true;
			code = source.string.charCodeAt(++position + source.start);
			if(code == 43 || code == 45) {
				code = source.string.charCodeAt(++position + source.start);
			}
			position = this.readDigits(source,position,code);
		}
		var range_min = start;
		var range_max = position;
		return graphql_parser_TokUtil.asToken(isFloat ? "Float" : "Int",start,position,line,col,prev,graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min) + body.start,graphql_parser_StringSlice.clamp(body,range_max) + body.start).toString());
	}
	,readDigits: function(source,start,firstCode) {
		var body = source;
		var position = start;
		var code = firstCode;
		if(code >= 48 && code <= 57) {
			while(true) {
				code = source.string.charCodeAt(++position + source.start);
				if(!(code >= 48 && code <= 57)) {
					break;
				}
			}
			return position;
		}
		throw haxe_Exception.thrown(this.syntaxError(source,this.line,this.lineStart,position,"Invalid number, expected digit but got: " + this.printCharCode(code) + "."));
	}
	,readString: function(source,start,line,col,prev) {
		var body = source;
		var position = start + 1;
		var chunkStart = position;
		var code = 0;
		var value = "";
		while(true) {
			var tmp;
			if(position < body.length) {
				code = source.string.charCodeAt(position + source.start);
				tmp = code != null;
			} else {
				tmp = false;
			}
			if(!(tmp && code != 10 && code != 13)) {
				break;
			}
			if(code == 34) {
				var range_min = chunkStart;
				var range_max = position;
				var tmp1 = graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min) + body.start,graphql_parser_StringSlice.clamp(body,range_max) + body.start);
				value += tmp1 == null ? "null" : tmp1.toString();
				return graphql_parser_TokUtil.asToken("String",start,position + 1,line,col,prev,value);
			}
			if(code < 32 && code != 9) {
				throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,position,"Invalid character within String: " + this.printCharCode(code) + "."));
			}
			++position;
			if(code == 92) {
				var range_min1 = chunkStart;
				var range_max1 = position - 1;
				var tmp2 = graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min1) + body.start,graphql_parser_StringSlice.clamp(body,range_max1) + body.start);
				value += tmp2 == null ? "null" : tmp2.toString();
				code = source.string.charCodeAt(position + source.start);
				switch(code) {
				case 34:
					value += "\"";
					break;
				case 47:
					value += "/";
					break;
				case 92:
					value += "\\";
					break;
				case 98:
					value += "\x08";
					break;
				case 102:
					value += "\x0C";
					break;
				case 110:
					value += "\n";
					break;
				case 114:
					value += "\r";
					break;
				case 116:
					value += "\t";
					break;
				case 117:
					var charCode = this.uniCharCode(source.string.charCodeAt(position + 1 + source.start),source.string.charCodeAt(position + 2 + source.start),source.string.charCodeAt(position + 3 + source.start),source.string.charCodeAt(position + 4 + source.start));
					if(charCode < 0) {
						var tmp3 = this.lineStart;
						var range_min2 = position + 1;
						var range_max2 = position + 5;
						var tmp4 = graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min2) + body.start,graphql_parser_StringSlice.clamp(body,range_max2) + body.start);
						throw haxe_Exception.thrown(this.syntaxError(source,line,tmp3,position,"Invalid character escape sequence: " + ("\\u" + (tmp4 == null ? "null" : tmp4.toString()) + ".")));
					}
					value += String.fromCodePoint(charCode);
					position += 4;
					break;
				default:
					throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,position,"Invalid character escape sequence: " + String.fromCodePoint(code) + "."));
				}
				++position;
				chunkStart = position;
			}
		}
		throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,position,"Unterminated string."));
	}
	,readBlockString: function(source,start,line,col,prev) {
		var body = source;
		var position = start + 3;
		var chunkStart = position;
		var code = 0;
		var rawValue = "";
		while(true) {
			var tmp;
			if(position < body.length) {
				code = source.string.charCodeAt(position + source.start);
				tmp = code != null;
			} else {
				tmp = false;
			}
			if(!tmp) {
				break;
			}
			if(code == 34 && source.string.charCodeAt(position + 1 + source.start) == 34 && source.string.charCodeAt(position + 2 + source.start) == 34) {
				var range_min = chunkStart;
				var range_max = position;
				var tmp1 = graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min) + body.start,graphql_parser_StringSlice.clamp(body,range_max) + body.start);
				rawValue += tmp1 == null ? "null" : tmp1.toString();
				var tmp2 = position + 3;
				throw haxe_Exception.thrown("TODO: implement blockStringValue(rawValue)");
			}
			if(code < 32 && code != 9 && code != 10 && code != 13) {
				throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,position,"Invalid character within String: " + this.printCharCode(code) + "."));
			}
			if(code == 92 && source.string.charCodeAt(position + 1 + source.start) == 34 && source.string.charCodeAt(position + 2 + source.start) == 34 && source.string.charCodeAt(position + 3 + source.start) == 34) {
				var range_min1 = chunkStart;
				var range_max1 = position;
				var tmp3 = graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min1) + body.start,graphql_parser_StringSlice.clamp(body,range_max1) + body.start);
				rawValue += (tmp3 == null ? "null" : tmp3.toString()) + "\"\"\"";
				position += 4;
				chunkStart = position;
			} else {
				++position;
			}
		}
		throw haxe_Exception.thrown(this.syntaxError(source,line,this.lineStart,position,"Unterminated string."));
	}
	,uniCharCode: function(a,b,c,d) {
		return this.char2hex(a) << 12 | this.char2hex(b) << 8 | this.char2hex(c) << 4 | this.char2hex(d);
	}
	,char2hex: function(a) {
		if(a >= 48 && a <= 57) {
			return a - 48;
		} else if(a >= 65 && a <= 70) {
			return a - 55;
		} else if(a >= 97 && a <= 102) {
			return a - 87;
		} else {
			return -1;
		}
	}
	,readName: function(source,start,line,col,prev) {
		var body = source;
		var bodyLength = body.length;
		var position = start + 1;
		var code = 0;
		while(true) {
			var tmp;
			if(position != bodyLength) {
				code = source.string.charCodeAt(position + source.start);
				tmp = code != null;
			} else {
				tmp = false;
			}
			if(!(tmp && (code == 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122))) {
				break;
			}
			++position;
		}
		var range_min = start;
		var range_max = position;
		return graphql_parser_TokUtil.asToken("Name",start,position,line,col,prev,graphql_parser_StringSlice._new(body.string,graphql_parser_StringSlice.wrap(body,range_min) + body.start,graphql_parser_StringSlice.clamp(body,range_max) + body.start).toString());
	}
	,syntaxError: function(source,line,col,start,msg) {
		return graphql_parser_Parser.syntaxError(source,line,col,start,msg);
	}
	,__class__: graphql_parser_GeneratedLexer
};
var graphql_parser_TokUtil = function() { };
graphql_parser_TokUtil.__name__ = "graphql.parser.TokUtil";
graphql_parser_TokUtil.asToken = function(kind,start,end,line,column,prev,value) {
	return { kind : kind, start : start, end : end, line : line, column : column, value : value, prev : prev, next : null};
};
var haxe_ds_StringMap = function() {
	this.h = Object.create(null);
};
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
haxe_ds_StringMap.prototype = {
	h: null
	,__class__: haxe_ds_StringMap
};
var graphql_parser_GeneratedParser = function() {
};
graphql_parser_GeneratedParser.__name__ = "graphql.parser.GeneratedParser";
graphql_parser_GeneratedParser.prototype = {
	parseName: function(lexer) {
		var token = this.expect(lexer,"Name");
		return { kind : "Name", value : token.value, loc : this.loc(lexer,token)};
	}
	,parseDocument: function(lexer) {
		var start = lexer.token;
		this.expect(lexer,"<SOF>");
		var definitions = [];
		while(true) {
			definitions.push(this.parseDefinition(lexer));
			if(this.skip(lexer,"<EOF>")) {
				break;
			}
		}
		return { kind : "Document", definitions : definitions, loc : this.loc(lexer,start)};
	}
	,parseDefinition: function(lexer) {
		if(this.peek(lexer,"Name")) {
			switch(lexer.token.value) {
			case "fragment":case "mutation":case "query":case "subscription":
				return this.parseExecutableDefinition(lexer);
			case "directive":case "enum":case "extend":case "input":case "interface":case "scalar":case "schema":case "type":case "union":
				return this.parseTypeSystemDefinition(lexer);
			}
		} else if(this.peek(lexer,"{")) {
			return this.parseExecutableDefinition(lexer);
		} else if(this.peekDescription(lexer)) {
			return this.parseTypeSystemDefinition(lexer);
		}
		throw haxe_Exception.thrown(this.unexpected(lexer));
	}
	,parseExecutableDefinition: function(lexer) {
		if(this.peek(lexer,"Name")) {
			switch(lexer.token.value) {
			case "fragment":
				return this.parseFragmentDefinition(lexer);
			case "mutation":case "query":case "subscription":
				return this.parseOperationDefinition(lexer);
			}
		} else if(this.peek(lexer,"{")) {
			return this.parseOperationDefinition(lexer);
		}
		throw haxe_Exception.thrown(this.unexpected(lexer));
	}
	,parseOperationDefinition: function(lexer) {
		var start = lexer.token;
		if(this.peek(lexer,"{")) {
			return { kind : "OperationDefinition", operation : "query", name : null, variableDefinitions : [], directives : [], selectionSet : this.parseSelectionSet(lexer), loc : this.loc(lexer,start)};
		}
		var operation = this.parseOperationType(lexer);
		var name = null;
		if(this.peek(lexer,"Name")) {
			name = this.parseName(lexer);
		}
		return { kind : "OperationDefinition", operation : operation, name : name, variableDefinitions : this.parseVariableDefinitions(lexer), directives : this.parseDirectives(lexer,false), selectionSet : this.parseSelectionSet(lexer), loc : this.loc(lexer,start)};
	}
	,parseOperationType: function(lexer) {
		var operationToken = this.expect(lexer,"Name");
		switch(operationToken.value) {
		case "mutation":
			return "mutation";
		case "query":
			return "query";
		case "subscription":
			return "subscription";
		}
		throw haxe_Exception.thrown(this.unexpected(lexer,operationToken));
	}
	,parseVariableDefinitions: function(lexer) {
		if(this.peek(lexer,"(")) {
			return this.many(lexer,"(",$bind(this,this.parseVariableDefinition),")");
		} else {
			return [];
		}
	}
	,parseVariableDefinition: function(lexer) {
		var start = lexer.token;
		var tmp = this.parseVariable(lexer);
		this.expect(lexer,":");
		return { kind : "VariableDefinition", variable : tmp, type : this.parseTypeReference(lexer), defaultValue : this.skip(lexer,"=") ? this.parseValueLiteral(lexer,true) : null, loc : this.loc(lexer,start)};
	}
	,parseVariable: function(lexer) {
		var start = lexer.token;
		this.expect(lexer,"$");
		return { kind : "Variable", name : this.parseName(lexer), loc : this.loc(lexer,start)};
	}
	,parseSelectionSet: function(lexer) {
		var start = lexer.token;
		return { kind : "SelectionSet", selections : this.many(lexer,"{",$bind(this,this.parseSelection),"}"), loc : this.loc(lexer,start)};
	}
	,parseSelection: function(lexer) {
		if(this.peek(lexer,"...")) {
			return this.parseFragment(lexer);
		} else {
			return this.parseField(lexer);
		}
	}
	,parseField: function(lexer) {
		var start = lexer.token;
		var nameOrAlias = this.parseName(lexer);
		var alias = null;
		var name = null;
		if(this.skip(lexer,":")) {
			alias = nameOrAlias;
			name = this.parseName(lexer);
		} else {
			name = nameOrAlias;
		}
		return { kind : "Field", alias : alias, name : name, 'arguments' : this.parseArguments(lexer,false), directives : this.parseDirectives(lexer,false), selectionSet : this.peek(lexer,"{") ? this.parseSelectionSet(lexer) : null, loc : this.loc(lexer,start)};
	}
	,parseArguments: function(lexer,isConst) {
		var item = isConst ? $bind(this,this.parseConstArgument) : $bind(this,this.parseArgument);
		if(this.peek(lexer,"(")) {
			return this.many(lexer,"(",item,")");
		} else {
			return [];
		}
	}
	,parseArgument: function(lexer) {
		var start = lexer.token;
		var tmp = this.parseName(lexer);
		this.expect(lexer,":");
		return { kind : "Argument", name : tmp, value : this.parseValueLiteral(lexer,false), loc : this.loc(lexer,start)};
	}
	,parseConstArgument: function(lexer) {
		var start = lexer.token;
		var tmp = this.parseName(lexer);
		this.expect(lexer,":");
		return { kind : "Argument", name : tmp, value : this.parseConstValue(lexer), loc : this.loc(lexer,start)};
	}
	,parseFragment: function(lexer) {
		var start = lexer.token;
		this.expect(lexer,"...");
		if(this.peek(lexer,"Name") && lexer.token.value != "on") {
			return { kind : "FragmentSpread", name : this.parseFragmentName(lexer), directives : this.parseDirectives(lexer,false), loc : this.loc(lexer,start)};
		}
		var typeCondition = null;
		if(lexer.token.value == "on") {
			lexer.advance();
			typeCondition = this.parseNamedType(lexer);
		}
		return { kind : "InlineFragment", typeCondition : typeCondition, directives : this.parseDirectives(lexer,false), selectionSet : this.parseSelectionSet(lexer), loc : this.loc(lexer,start)};
	}
	,parseFragmentDefinition: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"fragment");
		if(lexer.options.experimentalFragmentVariables) {
			var tmp = this.parseFragmentName(lexer);
			var tmp1 = this.parseVariableDefinitions(lexer);
			this.expectKeyword(lexer,"on");
			return { kind : "FragmentDefinition", name : tmp, variableDefinitions : tmp1, typeCondition : this.parseNamedType(lexer), directives : this.parseDirectives(lexer,false), selectionSet : this.parseSelectionSet(lexer), loc : this.loc(lexer,start)};
		}
		var tmp = this.parseFragmentName(lexer);
		this.expectKeyword(lexer,"on");
		return { kind : "FragmentDefinition", name : tmp, typeCondition : this.parseNamedType(lexer), directives : this.parseDirectives(lexer,false), selectionSet : this.parseSelectionSet(lexer), loc : this.loc(lexer,start)};
	}
	,parseFragmentName: function(lexer) {
		if(lexer.token.value == "on") {
			throw haxe_Exception.thrown(this.unexpected(lexer));
		}
		return this.parseName(lexer);
	}
	,parseValueLiteral: function(lexer,isConst) {
		var token = lexer.token;
		switch(token.kind) {
		case "$":
			if(!isConst) {
				return this.parseVariable(lexer);
			}
			break;
		case "Float":
			lexer.advance();
			return { kind : "FloatValue", value : token.value, loc : this.loc(lexer,token)};
		case "Int":
			lexer.advance();
			return { kind : "IntValue", value : token.value, loc : this.loc(lexer,token)};
		case "Name":
			if(token.value == "true" || token.value == "false") {
				lexer.advance();
				return { kind : "BooleanValue", value : token.value == "true", loc : this.loc(lexer,token)};
			} else if(token.value == "null") {
				lexer.advance();
				return { kind : "NullValue", loc : this.loc(lexer,token)};
			}
			lexer.advance();
			return { kind : "EnumValue", value : token.value, loc : this.loc(lexer,token)};
		case "BlockString":case "String":
			return this.parseStringLiteral(lexer);
		case "[":
			return this.parseList(lexer,isConst);
		case "{":
			return this.parseObject(lexer,isConst);
		default:
		}
		throw haxe_Exception.thrown(this.unexpected(lexer));
	}
	,parseStringLiteral: function(lexer) {
		var token = lexer.token;
		lexer.advance();
		return { kind : "StringValue", value : token.value, block : token.kind == "BlockString", loc : this.loc(lexer,token)};
	}
	,parseConstValue: function(lexer) {
		return this.parseValueLiteral(lexer,true);
	}
	,parseValueValue: function(lexer) {
		return this.parseValueLiteral(lexer,false);
	}
	,parseList: function(lexer,isConst) {
		var start = lexer.token;
		var item = isConst ? $bind(this,this.parseConstValue) : $bind(this,this.parseValueValue);
		return { kind : "ListValue", values : this.any(lexer,"[",item,"]"), loc : this.loc(lexer,start)};
	}
	,parseObject: function(lexer,isConst) {
		var start = lexer.token;
		this.expect(lexer,"{");
		var fields = [];
		while(!this.skip(lexer,"}")) fields.push(this.parseObjectField(lexer,isConst));
		return { kind : "ObjectValue", fields : fields, loc : this.loc(lexer,start)};
	}
	,parseObjectField: function(lexer,isConst) {
		var start = lexer.token;
		var tmp = this.parseName(lexer);
		this.expect(lexer,":");
		return { kind : "ObjectField", name : tmp, value : this.parseValueLiteral(lexer,isConst), loc : this.loc(lexer,start)};
	}
	,parseDirectives: function(lexer,isConst) {
		var directives = [];
		while(this.peek(lexer,"@")) directives.push(this.parseDirective(lexer,isConst));
		return directives;
	}
	,parseDirective: function(lexer,isConst) {
		var start = lexer.token;
		this.expect(lexer,"@");
		return { kind : "Directive", name : this.parseName(lexer), 'arguments' : this.parseArguments(lexer,isConst), loc : this.loc(lexer,start)};
	}
	,parseTypeReference: function(lexer) {
		var start = lexer.token;
		var type = null;
		if(this.skip(lexer,"[")) {
			type = this.parseTypeReference(lexer);
			this.expect(lexer,"]");
			type = { kind : "ListType", type : type, loc : this.loc(lexer,start)};
		} else {
			type = this.parseNamedType(lexer);
		}
		if(this.skip(lexer,"!")) {
			return { kind : "NonNullType", type : type, loc : this.loc(lexer,start)};
		}
		return type;
	}
	,parseNamedType: function(lexer) {
		var start = lexer.token;
		return { kind : "NamedType", name : this.parseName(lexer), loc : this.loc(lexer,start)};
	}
	,parseTypeSystemDefinition: function(lexer) {
		var keywordToken = this.peekDescription(lexer) ? lexer.lookahead() : lexer.token;
		if(keywordToken.kind == "Name") {
			switch(keywordToken.value) {
			case "directive":
				return this.parseDirectiveDefinition(lexer);
			case "enum":
				return this.parseEnumTypeDefinition(lexer);
			case "extend":
				return this.parseTypeExtension(lexer);
			case "input":
				return this.parseInputObjectTypeDefinition(lexer);
			case "interface":
				return this.parseInterfaceTypeDefinition(lexer);
			case "scalar":
				return this.parseScalarTypeDefinition(lexer);
			case "schema":
				return this.parseSchemaDefinition(lexer);
			case "type":
				return this.parseObjectTypeDefinition(lexer);
			case "union":
				return this.parseUnionTypeDefinition(lexer);
			}
		}
		throw haxe_Exception.thrown(this.unexpected(lexer,keywordToken));
	}
	,peekDescription: function(lexer) {
		if(!this.peek(lexer,"String")) {
			return this.peek(lexer,"BlockString");
		} else {
			return true;
		}
	}
	,parseDescription: function(lexer) {
		if(!this.peekDescription(lexer)) {
			return null;
		}
		return this.parseStringLiteral(lexer);
	}
	,parseSchemaDefinition: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"schema");
		var directives = this.parseDirectives(lexer,true);
		var operationTypes = this.many(lexer,"{",$bind(this,this.parseOperationTypeDefinition),"}");
		return { kind : "SchemaDefinition", directives : directives, operationTypes : operationTypes, loc : this.loc(lexer,start)};
	}
	,parseOperationTypeDefinition: function(lexer) {
		var start = lexer.token;
		var operation = this.parseOperationType(lexer);
		this.expect(lexer,":");
		var type = this.parseNamedType(lexer);
		return { kind : "OperationTypeDefinition", operation : operation, type : type, loc : this.loc(lexer,start)};
	}
	,parseScalarTypeDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		this.expectKeyword(lexer,"scalar");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		return { kind : "ScalarTypeDefinition", description : description, name : name, directives : directives, loc : this.loc(lexer,start)};
	}
	,parseObjectTypeDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		this.expectKeyword(lexer,"type");
		var name = this.parseName(lexer);
		var interfaces = this.parseImplementsInterfaces(lexer);
		var directives = this.parseDirectives(lexer,true);
		var fields = this.parseFieldsDefinition(lexer);
		return { kind : "ObjectTypeDefinition", description : description, name : name, interfaces : interfaces, directives : directives, fields : fields, loc : this.loc(lexer,start)};
	}
	,parseImplementsInterfaces: function(lexer) {
		var types = [];
		if(lexer.token.value == "implements") {
			lexer.advance();
			this.skip(lexer,"&");
			while(true) {
				types.push(this.parseNamedType(lexer));
				if(!(this.skip(lexer,"&") || lexer.options.allowLegacySDLImplementsInterfaces && this.peek(lexer,"Name"))) {
					break;
				}
			}
		}
		return types;
	}
	,parseFieldsDefinition: function(lexer) {
		if(lexer.options.allowLegacySDLEmptyFields && this.peek(lexer,"{") && lexer.lookahead().kind == "}") {
			lexer.advance();
			lexer.advance();
			return [];
		}
		if(this.peek(lexer,"{")) {
			return this.many(lexer,"{",$bind(this,this.parseFieldDefinition),"}");
		} else {
			return [];
		}
	}
	,parseFieldDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		var name = this.parseName(lexer);
		var args = this.parseArgumentDefs(lexer);
		this.expect(lexer,":");
		var type = this.parseTypeReference(lexer);
		var directives = this.parseDirectives(lexer,true);
		return { kind : "FieldDefinition", description : description, name : name, 'arguments' : args, type : type, directives : directives, loc : this.loc(lexer,start)};
	}
	,parseArgumentDefs: function(lexer) {
		if(!this.peek(lexer,"(")) {
			return [];
		}
		return this.many(lexer,"(",$bind(this,this.parseInputValueDef),")");
	}
	,parseInputValueDef: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		var name = this.parseName(lexer);
		this.expect(lexer,":");
		var type = this.parseTypeReference(lexer);
		var defaultValue = null;
		if(this.skip(lexer,"=")) {
			defaultValue = this.parseConstValue(lexer);
		}
		var directives = this.parseDirectives(lexer,true);
		return { kind : "InputValueDefinition", description : description, name : name, type : type, defaultValue : defaultValue, directives : directives, loc : this.loc(lexer,start)};
	}
	,parseInterfaceTypeDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		this.expectKeyword(lexer,"interface");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var fields = this.parseFieldsDefinition(lexer);
		return { kind : "InterfaceTypeDefinition", description : description, name : name, directives : directives, fields : fields, loc : this.loc(lexer,start)};
	}
	,parseUnionTypeDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		this.expectKeyword(lexer,"union");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var types = this.parseUnionMemberTypes(lexer);
		return { kind : "UnionTypeDefinition", description : description, name : name, directives : directives, types : types, loc : this.loc(lexer,start)};
	}
	,parseUnionMemberTypes: function(lexer) {
		var types = [];
		if(this.skip(lexer,"=")) {
			this.skip(lexer,"|");
			while(true) {
				types.push(this.parseNamedType(lexer));
				if(!this.skip(lexer,"|")) {
					break;
				}
			}
		}
		return types;
	}
	,parseEnumTypeDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		this.expectKeyword(lexer,"enum");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var values = this.parseEnumValuesDefinition(lexer);
		return { kind : "EnumTypeDefinition", description : description, name : name, directives : directives, values : values, loc : this.loc(lexer,start)};
	}
	,parseEnumValuesDefinition: function(lexer) {
		if(this.peek(lexer,"{")) {
			return this.many(lexer,"{",$bind(this,this.parseEnumValueDefinition),"}");
		} else {
			return [];
		}
	}
	,parseEnumValueDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		return { kind : "EnumValueDefinition", description : description, name : name, directives : directives, loc : this.loc(lexer,start)};
	}
	,parseInputObjectTypeDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		this.expectKeyword(lexer,"input");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var fields = this.parseInputFieldsDefinition(lexer);
		return { kind : "InputObjectTypeDefinition", description : description, name : name, directives : directives, fields : fields, loc : this.loc(lexer,start)};
	}
	,parseInputFieldsDefinition: function(lexer) {
		if(this.peek(lexer,"{")) {
			return this.many(lexer,"{",$bind(this,this.parseInputValueDef),"}");
		} else {
			return [];
		}
	}
	,parseTypeExtension: function(lexer) {
		var keywordToken = lexer.lookahead();
		if(keywordToken.kind == "Name") {
			switch(keywordToken.value) {
			case "enum":
				return this.parseEnumTypeExtension(lexer);
			case "input":
				return this.parseInputObjectTypeExtension(lexer);
			case "interface":
				return this.parseInterfaceTypeExtension(lexer);
			case "scalar":
				return this.parseScalarTypeExtension(lexer);
			case "type":
				return this.parseObjectTypeExtension(lexer);
			case "union":
				return this.parseUnionTypeExtension(lexer);
			}
		}
		throw haxe_Exception.thrown(this.unexpected(lexer,keywordToken));
	}
	,parseScalarTypeExtension: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"extend");
		this.expectKeyword(lexer,"scalar");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		if(directives.length == 0) {
			throw haxe_Exception.thrown(this.unexpected(lexer));
		}
		return { kind : "ScalarTypeExtension", name : name, directives : directives, loc : this.loc(lexer,start)};
	}
	,parseObjectTypeExtension: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"extend");
		this.expectKeyword(lexer,"type");
		var name = this.parseName(lexer);
		var interfaces = this.parseImplementsInterfaces(lexer);
		var directives = this.parseDirectives(lexer,true);
		var fields = this.parseFieldsDefinition(lexer);
		if(interfaces.length == 0 && directives.length == 0 && fields.length == 0) {
			throw haxe_Exception.thrown(this.unexpected(lexer));
		}
		return { kind : "ObjectTypeExtension", name : name, interfaces : interfaces, directives : directives, fields : fields, loc : this.loc(lexer,start)};
	}
	,parseInterfaceTypeExtension: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"extend");
		this.expectKeyword(lexer,"interface");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var fields = this.parseFieldsDefinition(lexer);
		if(directives.length == 0 && fields.length == 0) {
			throw haxe_Exception.thrown(this.unexpected(lexer));
		}
		return { kind : "InterfaceTypeExtension", name : name, directives : directives, fields : fields, loc : this.loc(lexer,start)};
	}
	,parseUnionTypeExtension: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"extend");
		this.expectKeyword(lexer,"union");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var types = this.parseUnionMemberTypes(lexer);
		if(directives.length == 0 && types.length == 0) {
			throw haxe_Exception.thrown(this.unexpected(lexer));
		}
		return { kind : "UnionTypeExtension", name : name, directives : directives, types : types, loc : this.loc(lexer,start)};
	}
	,parseEnumTypeExtension: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"extend");
		this.expectKeyword(lexer,"enum");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var values = this.parseEnumValuesDefinition(lexer);
		if(directives.length == 0 && values.length == 0) {
			throw haxe_Exception.thrown(this.unexpected(lexer));
		}
		return { kind : "EnumTypeExtension", name : name, directives : directives, values : values, loc : this.loc(lexer,start)};
	}
	,parseInputObjectTypeExtension: function(lexer) {
		var start = lexer.token;
		this.expectKeyword(lexer,"extend");
		this.expectKeyword(lexer,"input");
		var name = this.parseName(lexer);
		var directives = this.parseDirectives(lexer,true);
		var fields = this.parseInputFieldsDefinition(lexer);
		if(directives.length == 0 && fields.length == 0) {
			throw haxe_Exception.thrown(this.unexpected(lexer));
		}
		return { kind : "InputObjectTypeExtension", name : name, directives : directives, fields : fields, loc : this.loc(lexer,start)};
	}
	,parseDirectiveDefinition: function(lexer) {
		var start = lexer.token;
		var description = this.parseDescription(lexer);
		this.expectKeyword(lexer,"directive");
		this.expect(lexer,"@");
		var name = this.parseName(lexer);
		var args = this.parseArgumentDefs(lexer);
		this.expectKeyword(lexer,"on");
		var locations = this.parseDirectiveLocations(lexer);
		return { kind : "DirectiveDefinition", description : description, name : name, 'arguments' : args, locations : locations, loc : this.loc(lexer,start)};
	}
	,parseDirectiveLocations: function(lexer) {
		this.skip(lexer,"|");
		var locations = [];
		while(true) {
			locations.push(this.parseDirectiveLocation(lexer));
			if(!this.skip(lexer,"|")) {
				break;
			}
		}
		return locations;
	}
	,parseDirectiveLocation: function(lexer) {
		var start = lexer.token;
		var name = this.parseName(lexer);
		if(graphql_parser_GeneratedParser.ValidDirectiveLocations.h[name.value]) {
			return name;
		}
		throw haxe_Exception.thrown(this.unexpected(lexer,start));
	}
	,peek: function(lexer,kind) {
		return lexer.token.kind == kind;
	}
	,skip: function(lexer,kind) {
		var match = lexer.token.kind == kind;
		if(match) {
			lexer.advance();
		}
		return match;
	}
	,expect: function(lexer,kind) {
		var token = lexer.token;
		if(token.kind == kind) {
			lexer.advance();
			return token;
		}
		throw haxe_Exception.thrown(this.syntaxError(lexer.source,lexer.line,lexer.lineStart,token.start,"Expected " + kind + ", found " + this.getTokenDesc(token)));
	}
	,expectKeyword: function(lexer,value) {
		var token = lexer.token;
		if(token.kind == "Name" && token.value == value) {
			lexer.advance();
			return token;
		}
		throw haxe_Exception.thrown(this.syntaxError(lexer.source,lexer.line,lexer.lineStart,token.start,"Expected \"" + value + "\", found " + this.getTokenDesc(token)));
	}
	,unexpected: function(lexer,atToken) {
		var token = atToken != null ? atToken : lexer.token;
		return this.syntaxError(lexer.source,lexer.line,lexer.lineStart,token.start,"Unexpected " + this.getTokenDesc(token));
	}
	,any: function(lexer,openKind,parseFn,closeKind) {
		this.expect(lexer,openKind);
		var nodes = [];
		while(!this.skip(lexer,closeKind)) nodes.push(parseFn(lexer));
		return nodes;
	}
	,many: function(lexer,openKind,parseFn,closeKind) {
		this.expect(lexer,openKind);
		var nodes = [parseFn(lexer)];
		while(!this.skip(lexer,closeKind)) nodes.push(parseFn(lexer));
		return nodes;
	}
	,loc: function(lexer,startToken) {
		if(lexer.options != null && lexer.options.noLocation) {
			return null;
		}
		return { start : startToken.start, end : lexer.lastToken.end, startToken : startToken, endToken : lexer.lastToken, source : lexer.source};
	}
	,syntaxError: function(source,line,lineStart,start,msg) {
		return graphql_parser_Parser.syntaxError(source,line,lineStart,start,msg);
	}
	,getTokenDesc: function(t) {
		return t.kind;
	}
	,__class__: graphql_parser_GeneratedParser
};
var graphql_parser_Pos = function(file,min,max,line,col) {
	this.file = file;
	this.min = min;
	this.max = max;
	this.line = line;
	this.col = col;
};
graphql_parser_Pos.__name__ = "graphql.parser.Pos";
graphql_parser_Pos.prototype = {
	file: null
	,min: null
	,max: null
	,line: null
	,col: null
	,__class__: graphql_parser_Pos
};
var graphql_parser_Err = function(message,pos) {
	this.message = message;
	this.pos = pos;
};
graphql_parser_Err.__name__ = "graphql.parser.Err";
graphql_parser_Err.prototype = {
	message: null
	,pos: null
	,__class__: graphql_parser_Err
};
var graphql_parser_Parser = function(graphql_source,options,filename) {
	if(filename == null) {
		filename = "Untitled";
	}
	var parser = new graphql_parser_GeneratedParser();
	if(options == null) {
		options = { };
	}
	var lexer = graphql_parser_GeneratedLexer.createLexer(graphql_parser_StringSlice.ofString(graphql_source),options);
	try {
		this.document = parser.parseDocument(lexer);
	} catch( _g ) {
		var _g1 = haxe_Exception.caught(_g).unwrap();
		if(((_g1) instanceof graphql_parser_Err)) {
			var e = _g1;
			var posmsg = e.pos != null ? "" + e.pos.line + ": characters " + e.pos.col + "-" + (e.pos.col + (e.pos.max - e.pos.min + 1)) : "";
			throw haxe_Exception.thrown("" + filename + ":" + posmsg + " Error: " + e.message);
		} else {
			throw _g;
		}
	}
};
graphql_parser_Parser.__name__ = "graphql.parser.Parser";
graphql_parser_Parser.syntaxError = function(source,line,lineStart,start,msg) {
	var col = start - lineStart;
	return new graphql_parser_Err(msg,new graphql_parser_Pos(null,start,start,line,col));
};
graphql_parser_Parser.prototype = {
	document: null
	,__class__: graphql_parser_Parser
};
var graphql_parser__$StringSlice_Data = function(string,start,end) {
	this.string = string;
	this.start = start;
	this.end = end;
	if((this.length = end - start) < 0) {
		this.length = 0;
		this.end = this.start;
	}
};
graphql_parser__$StringSlice_Data.__name__ = "graphql.parser._StringSlice.Data";
graphql_parser__$StringSlice_Data.prototype = {
	string: null
	,start: null
	,end: null
	,length: null
	,representation: null
	,toString: function() {
		if(this.representation == null) {
			this.representation = this.string.substring(this.start,this.end);
		}
		return this.representation;
	}
	,__class__: graphql_parser__$StringSlice_Data
};
var graphql_parser_StringSlice = {};
graphql_parser_StringSlice._new = function(string,start,end) {
	var this1 = new graphql_parser__$StringSlice_Data(string,start == string.length ? start : start < 0 ? start % string.length + string.length : start % string.length,end == string.length ? end : end < 0 ? end % string.length + string.length : end % string.length);
	return this1;
};
graphql_parser_StringSlice.after = function(this1,index) {
	return new graphql_parser__$StringSlice_Data(this1.string,graphql_parser_StringSlice.wrap(this1,index) + this1.start,this1.end);
};
graphql_parser_StringSlice.before = function(this1,index) {
	return new graphql_parser__$StringSlice_Data(this1.string,this1.start,this1.start + graphql_parser_StringSlice.clamp(this1,index));
};
graphql_parser_StringSlice.clamp = function(this1,index) {
	if(index < 0) {
		if(-index > this1.length) {
			return 0;
		} else {
			return index + this1.length;
		}
	} else if(index > this1.length) {
		return this1.length;
	} else {
		return index;
	}
};
graphql_parser_StringSlice.wrap = function(this1,index) {
	if(this1.length == 0) {
		return 0;
	} else if(index < 0) {
		return index % this1.length + this1.length;
	} else {
		return index % this1.length;
	}
};
graphql_parser_StringSlice.get = function(this1,index) {
	var index1 = graphql_parser_StringSlice.wrap(this1,index);
	return this1.string.charCodeAt(index1 + this1.start);
};
graphql_parser_StringSlice.slice = function(this1,range) {
	return graphql_parser_StringSlice._new(this1.string,graphql_parser_StringSlice.wrap(this1,range.min) + this1.start,graphql_parser_StringSlice.clamp(this1,range.max) + this1.start);
};
graphql_parser_StringSlice.fastGet = function(this1,index) {
	return this1.string.charCodeAt(index + this1.start);
};
graphql_parser_StringSlice.toString = function(this1) {
	return this1.toString();
};
graphql_parser_StringSlice.ofString = function(s) {
	if(s == null || s == "") {
		return graphql_parser_StringSlice.EMPTY;
	} else if(s.length == 1) {
		var ascii = s.charCodeAt(0);
		if(ascii < graphql_parser_StringSlice.CHARS.length) {
			return graphql_parser_StringSlice.CHARS[ascii];
		} else {
			return new graphql_parser__$StringSlice_Data(s,0,s.length);
		}
	} else {
		return new graphql_parser__$StringSlice_Data(s,0,s.length);
	}
};
graphql_parser_StringSlice.startsWith = function(this1,other) {
	return graphql_parser_StringSlice.hasSub(this1,other);
};
graphql_parser_StringSlice.hasSub = function(this1,other,at) {
	if(at == null) {
		at = 0;
	}
	at = graphql_parser_StringSlice.wrap(this1,at);
	if(at + other.length > this1.length) {
		return false;
	}
	var a = this1;
	var b = other;
	return graphql_parser_StringSlice.isEqual(a.string,a.start + at,other.length,b.string,b.start,b.length);
};
graphql_parser_StringSlice.indexOf = function(this1,end,pos) {
	if(pos == null) {
		pos = 0;
	}
	pos = graphql_parser_StringSlice.wrap(this1,pos);
	var _g = this1.string.indexOf(end.toString(),pos + this1.start);
	if(_g == -1) {
		return -1;
	} else {
		var v = _g;
		return v - this1.start;
	}
};
graphql_parser_StringSlice.isEqual = function(s1,p1,l1,s2,p2,l2) {
	if(l2 != l1) {
		return false;
	}
	var _g = 0;
	var _g1 = l2;
	while(_g < _g1) {
		var i = _g++;
		if(s1.charCodeAt(p1 + i) != s2.charCodeAt(p2 + i)) {
			return false;
		}
	}
	return true;
};
graphql_parser_StringSlice.equalsString = function(slice,string) {
	if(string == null || string.length != slice.length) {
		return false;
	} else {
		return graphql_parser_StringSlice.isEqual(slice.string,slice.start,slice.length,string,0,string.length);
	}
};
graphql_parser_StringSlice.equals = function(a,b) {
	if(a.length == b.length) {
		return graphql_parser_StringSlice.hasSub(a,b);
	} else {
		return false;
	}
};
var haxe_StackItem = $hxEnums["haxe.StackItem"] = { __ename__ : true, __constructs__ : ["CFunction","Module","FilePos","Method","LocalFunction"]
	,CFunction: {_hx_index:0,__enum__:"haxe.StackItem",toString:$estr}
	,Module: ($_=function(m) { return {_hx_index:1,m:m,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["m"],$_)
	,FilePos: ($_=function(s,file,line,column) { return {_hx_index:2,s:s,file:file,line:line,column:column,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["s","file","line","column"],$_)
	,Method: ($_=function(classname,method) { return {_hx_index:3,classname:classname,method:method,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["classname","method"],$_)
	,LocalFunction: ($_=function(v) { return {_hx_index:4,v:v,__enum__:"haxe.StackItem",toString:$estr}; },$_.__params__ = ["v"],$_)
};
var haxe_CallStack = {};
haxe_CallStack.callStack = function() {
	return haxe_NativeStackTrace.toHaxe(haxe_NativeStackTrace.callStack());
};
var haxe_Exception = function(message,previous,native) {
	Error.call(this,message);
	this.message = message;
	this.__previousException = previous;
	this.__nativeException = native != null ? native : this;
};
haxe_Exception.__name__ = "haxe.Exception";
haxe_Exception.caught = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value;
	} else if(((value) instanceof Error)) {
		return new haxe_Exception(value.message,null,value);
	} else {
		return new haxe_ValueException(value,null,value);
	}
};
haxe_Exception.thrown = function(value) {
	if(((value) instanceof haxe_Exception)) {
		return value.get_native();
	} else if(((value) instanceof Error)) {
		return value;
	} else {
		var e = new haxe_ValueException(value);
		return e;
	}
};
haxe_Exception.__super__ = Error;
haxe_Exception.prototype = $extend(Error.prototype,{
	__skipStack: null
	,__nativeException: null
	,__previousException: null
	,unwrap: function() {
		return this.__nativeException;
	}
	,get_native: function() {
		return this.__nativeException;
	}
	,__class__: haxe_Exception
});
var haxe_Log = function() { };
haxe_Log.__name__ = "haxe.Log";
haxe_Log.formatOutput = function(v,infos) {
	var str = Std.string(v);
	if(infos == null) {
		return str;
	}
	var pstr = infos.fileName + ":" + infos.lineNumber;
	if(infos.customParams != null) {
		var _g = 0;
		var _g1 = infos.customParams;
		while(_g < _g1.length) {
			var v = _g1[_g];
			++_g;
			str += ", " + Std.string(v);
		}
	}
	return pstr + ": " + str;
};
haxe_Log.trace = function(v,infos) {
	var str = haxe_Log.formatOutput(v,infos);
	if(typeof(console) != "undefined" && console.log != null) {
		console.log(str);
	}
};
var haxe_NativeStackTrace = function() { };
haxe_NativeStackTrace.__name__ = "haxe.NativeStackTrace";
haxe_NativeStackTrace.callStack = function() {
	var e = new Error("");
	var stack = haxe_NativeStackTrace.tryHaxeStack(e);
	if(typeof(stack) == "undefined") {
		try {
			throw e;
		} catch( _g ) {
		}
		stack = e.stack;
	}
	return haxe_NativeStackTrace.normalize(stack,2);
};
haxe_NativeStackTrace.toHaxe = function(s,skip) {
	if(skip == null) {
		skip = 0;
	}
	if(s == null) {
		return [];
	} else if(typeof(s) == "string") {
		var stack = s.split("\n");
		if(stack[0] == "Error") {
			stack.shift();
		}
		var m = [];
		var _g = 0;
		var _g1 = stack.length;
		while(_g < _g1) {
			var i = _g++;
			if(skip > i) {
				continue;
			}
			var line = stack[i];
			var matched = line.match(/^    at ([A-Za-z0-9_. ]+) \(([^)]+):([0-9]+):([0-9]+)\)$/);
			if(matched != null) {
				var path = matched[1].split(".");
				if(path[0] == "$hxClasses") {
					path.shift();
				}
				var meth = path.pop();
				var file = matched[2];
				var line1 = Std.parseInt(matched[3]);
				var column = Std.parseInt(matched[4]);
				m.push(haxe_StackItem.FilePos(meth == "Anonymous function" ? haxe_StackItem.LocalFunction() : meth == "Global code" ? null : haxe_StackItem.Method(path.join("."),meth),file,line1,column));
			} else {
				m.push(haxe_StackItem.Module(StringTools.trim(line)));
			}
		}
		return m;
	} else if(skip > 0 && Array.isArray(s)) {
		return s.slice(skip);
	} else {
		return s;
	}
};
haxe_NativeStackTrace.tryHaxeStack = function(e) {
	if(e == null) {
		return [];
	}
	var oldValue = Error.prepareStackTrace;
	Error.prepareStackTrace = haxe_NativeStackTrace.prepareHxStackTrace;
	var stack = e.stack;
	Error.prepareStackTrace = oldValue;
	return stack;
};
haxe_NativeStackTrace.prepareHxStackTrace = function(e,callsites) {
	var stack = [];
	var _g = 0;
	while(_g < callsites.length) {
		var site = callsites[_g];
		++_g;
		if(haxe_NativeStackTrace.wrapCallSite != null) {
			site = haxe_NativeStackTrace.wrapCallSite(site);
		}
		var method = null;
		var fullName = site.getFunctionName();
		if(fullName != null) {
			var idx = fullName.lastIndexOf(".");
			if(idx >= 0) {
				var className = fullName.substring(0,idx);
				var methodName = fullName.substring(idx + 1);
				method = haxe_StackItem.Method(className,methodName);
			} else {
				method = haxe_StackItem.Method(null,fullName);
			}
		}
		var fileName = site.getFileName();
		var fileAddr = fileName == null ? -1 : fileName.indexOf("file:");
		if(haxe_NativeStackTrace.wrapCallSite != null && fileAddr > 0) {
			fileName = fileName.substring(fileAddr + 6);
		}
		stack.push(haxe_StackItem.FilePos(method,fileName,site.getLineNumber(),site.getColumnNumber()));
	}
	return stack;
};
haxe_NativeStackTrace.normalize = function(stack,skipItems) {
	if(skipItems == null) {
		skipItems = 0;
	}
	if(Array.isArray(stack) && skipItems > 0) {
		return stack.slice(skipItems);
	} else if(typeof(stack) == "string") {
		switch(stack.substring(0,6)) {
		case "Error\n":case "Error:":
			++skipItems;
			break;
		default:
		}
		return haxe_NativeStackTrace.skipLines(stack,skipItems);
	} else {
		return stack;
	}
};
haxe_NativeStackTrace.skipLines = function(stack,skip,pos) {
	if(pos == null) {
		pos = 0;
	}
	if(skip > 0) {
		pos = stack.indexOf("\n",pos);
		if(pos < 0) {
			return "";
		} else {
			return haxe_NativeStackTrace.skipLines(stack,--skip,pos + 1);
		}
	} else {
		return stack.substring(pos);
	}
};
var haxe_ValueException = function(value,previous,native) {
	haxe_Exception.call(this,String(value),previous,native);
	this.value = value;
};
haxe_ValueException.__name__ = "haxe.ValueException";
haxe_ValueException.__super__ = haxe_Exception;
haxe_ValueException.prototype = $extend(haxe_Exception.prototype,{
	value: null
	,unwrap: function() {
		return this.value;
	}
	,__class__: haxe_ValueException
});
var haxe_http_HttpBase = function(url) {
	this.url = url;
	this.headers = [];
	this.params = [];
	this.emptyOnData = $bind(this,this.onData);
};
haxe_http_HttpBase.__name__ = "haxe.http.HttpBase";
haxe_http_HttpBase.prototype = {
	url: null
	,responseBytes: null
	,responseAsString: null
	,postData: null
	,postBytes: null
	,headers: null
	,params: null
	,emptyOnData: null
	,setParameter: function(name,value) {
		var _g = 0;
		var _g1 = this.params.length;
		while(_g < _g1) {
			var i = _g++;
			if(this.params[i].name == name) {
				this.params[i] = { name : name, value : value};
				return;
			}
		}
		this.params.push({ name : name, value : value});
	}
	,onData: function(data) {
	}
	,onBytes: function(data) {
	}
	,onError: function(msg) {
	}
	,onStatus: function(status) {
	}
	,hasOnData: function() {
		return !Reflect.compareMethods($bind(this,this.onData),this.emptyOnData);
	}
	,success: function(data) {
		this.responseBytes = data;
		this.responseAsString = null;
		if(this.hasOnData()) {
			this.onData(this.get_responseData());
		}
		this.onBytes(this.responseBytes);
	}
	,get_responseData: function() {
		if(this.responseAsString == null && this.responseBytes != null) {
			this.responseAsString = this.responseBytes.getString(0,this.responseBytes.length,haxe_io_Encoding.UTF8);
		}
		return this.responseAsString;
	}
	,__class__: haxe_http_HttpBase
};
var haxe_http_HttpJs = function(url) {
	this.async = true;
	this.withCredentials = false;
	haxe_http_HttpBase.call(this,url);
};
haxe_http_HttpJs.__name__ = "haxe.http.HttpJs";
haxe_http_HttpJs.__super__ = haxe_http_HttpBase;
haxe_http_HttpJs.prototype = $extend(haxe_http_HttpBase.prototype,{
	async: null
	,withCredentials: null
	,req: null
	,request: function(post) {
		var _gthis = this;
		this.responseAsString = null;
		this.responseBytes = null;
		var r = this.req = js_Browser.createXMLHttpRequest();
		var onreadystatechange = function(_) {
			if(r.readyState != 4) {
				return;
			}
			var s;
			try {
				s = r.status;
			} catch( _g ) {
				s = null;
			}
			if(s == 0 && typeof(window) != "undefined" && $global.location != null) {
				var protocol = $global.location.protocol.toLowerCase();
				var rlocalProtocol = new EReg("^(?:about|app|app-storage|.+-extension|file|res|widget):$","");
				var isLocal = rlocalProtocol.match(protocol);
				if(isLocal) {
					s = r.response != null ? 200 : 404;
				}
			}
			if(s == undefined) {
				s = null;
			}
			if(s != null) {
				_gthis.onStatus(s);
			}
			if(s != null && s >= 200 && s < 400) {
				_gthis.req = null;
				_gthis.success(haxe_io_Bytes.ofData(r.response));
			} else if(s == null || s == 0 && r.response == null) {
				_gthis.req = null;
				_gthis.onError("Failed to connect or resolve host");
			} else if(s == null) {
				_gthis.req = null;
				var onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
				_gthis.responseBytes = onreadystatechange;
				_gthis.onError("Http Error #" + r.status);
			} else {
				switch(s) {
				case 12007:
					_gthis.req = null;
					_gthis.onError("Unknown host");
					break;
				case 12029:
					_gthis.req = null;
					_gthis.onError("Failed to connect to host");
					break;
				default:
					_gthis.req = null;
					var onreadystatechange = r.response != null ? haxe_io_Bytes.ofData(r.response) : null;
					_gthis.responseBytes = onreadystatechange;
					_gthis.onError("Http Error #" + r.status);
				}
			}
		};
		if(this.async) {
			r.onreadystatechange = onreadystatechange;
		}
		var uri;
		var _g = this.postBytes;
		var _g1 = this.postData;
		if(_g1 == null) {
			if(_g == null) {
				uri = null;
			} else {
				var bytes = _g;
				uri = new Blob([bytes.b.bufferValue]);
			}
		} else if(_g == null) {
			var str = _g1;
			uri = str;
		} else {
			uri = null;
		}
		if(uri != null) {
			post = true;
		} else {
			var _g = 0;
			var _g1 = this.params;
			while(_g < _g1.length) {
				var p = _g1[_g];
				++_g;
				if(uri == null) {
					uri = "";
				} else {
					uri = (uri == null ? "null" : Std.string(uri)) + "&";
				}
				var s = p.name;
				var value = (uri == null ? "null" : Std.string(uri)) + encodeURIComponent(s) + "=";
				var s1 = p.value;
				uri = value + encodeURIComponent(s1);
			}
		}
		try {
			if(post) {
				r.open("POST",this.url,this.async);
			} else if(uri != null) {
				var question = this.url.split("?").length <= 1;
				r.open("GET",this.url + (question ? "?" : "&") + (uri == null ? "null" : Std.string(uri)),this.async);
				uri = null;
			} else {
				r.open("GET",this.url,this.async);
			}
			r.responseType = "arraybuffer";
		} catch( _g ) {
			var e = haxe_Exception.caught(_g).unwrap();
			this.req = null;
			this.onError(e.toString());
			return;
		}
		r.withCredentials = this.withCredentials;
		if(!Lambda.exists(this.headers,function(h) {
			return h.name == "Content-Type";
		}) && post && this.postData == null) {
			r.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
		}
		var _g = 0;
		var _g1 = this.headers;
		while(_g < _g1.length) {
			var h = _g1[_g];
			++_g;
			r.setRequestHeader(h.name,h.value);
		}
		r.send(uri);
		if(!this.async) {
			onreadystatechange(null);
		}
	}
	,__class__: haxe_http_HttpJs
});
var haxe_io_Bytes = function(data) {
	this.length = data.byteLength;
	this.b = new Uint8Array(data);
	this.b.bufferValue = data;
	data.hxBytes = this;
	data.bytes = this.b;
};
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
haxe_io_Bytes.ofData = function(b) {
	var hb = b.hxBytes;
	if(hb != null) {
		return hb;
	}
	return new haxe_io_Bytes(b);
};
haxe_io_Bytes.prototype = {
	length: null
	,b: null
	,getString: function(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		var s = "";
		var b = this.b;
		var i = pos;
		var max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			var debug = pos > 0;
			while(i < max) {
				var c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					var code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					var c2 = b[i++];
					var code1 = (c & 31) << 12 | (c2 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code1);
				} else {
					var c21 = b[i++];
					var c3 = b[i++];
					var u = (c & 15) << 18 | (c21 & 127) << 12 | (c3 & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				var c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	,__class__: haxe_io_Bytes
};
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__ : true, __constructs__ : ["UTF8","RawNative"]
	,UTF8: {_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__ : true, __constructs__ : ["Blocked","Overflow","OutsideBounds","Custom"]
	,Blocked: {_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_.__params__ = ["e"],$_)
};
var haxe_iterators_ArrayIterator = function(array) {
	this.current = 0;
	this.array = array;
};
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
haxe_iterators_ArrayIterator.prototype = {
	array: null
	,current: null
	,hasNext: function() {
		return this.current < this.array.length;
	}
	,next: function() {
		return this.array[this.current++];
	}
	,__class__: haxe_iterators_ArrayIterator
};
var js_Boot = function() { };
js_Boot.__name__ = "js.Boot";
js_Boot.getClass = function(o) {
	if(o == null) {
		return null;
	} else if(((o) instanceof Array)) {
		return Array;
	} else {
		var cl = o.__class__;
		if(cl != null) {
			return cl;
		}
		var name = js_Boot.__nativeClassName(o);
		if(name != null) {
			return js_Boot.__resolveNativeClass(name);
		}
		return null;
	}
};
js_Boot.__string_rec = function(o,s) {
	if(o == null) {
		return "null";
	}
	if(s.length >= 5) {
		return "<...>";
	}
	var t = typeof(o);
	if(t == "function" && (o.__name__ || o.__ename__)) {
		t = "object";
	}
	switch(t) {
	case "function":
		return "<function>";
	case "object":
		if(o.__enum__) {
			var e = $hxEnums[o.__enum__];
			var n = e.__constructs__[o._hx_index];
			var con = e[n];
			if(con.__params__) {
				s = s + "\t";
				return n + "(" + ((function($this) {
					var $r;
					var _g = [];
					{
						var _g1 = 0;
						var _g2 = con.__params__;
						while(true) {
							if(!(_g1 < _g2.length)) {
								break;
							}
							var p = _g2[_g1];
							_g1 = _g1 + 1;
							_g.push(js_Boot.__string_rec(o[p],s));
						}
					}
					$r = _g;
					return $r;
				}(this))).join(",") + ")";
			} else {
				return n;
			}
		}
		if(((o) instanceof Array)) {
			var str = "[";
			s += "\t";
			var _g = 0;
			var _g1 = o.length;
			while(_g < _g1) {
				var i = _g++;
				str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
			}
			str += "]";
			return str;
		}
		var tostr;
		try {
			tostr = o.toString;
		} catch( _g ) {
			return "???";
		}
		if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
			var s2 = o.toString();
			if(s2 != "[object Object]") {
				return s2;
			}
		}
		var str = "{\n";
		s += "\t";
		var hasp = o.hasOwnProperty != null;
		var k = null;
		for( k in o ) {
		if(hasp && !o.hasOwnProperty(k)) {
			continue;
		}
		if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
			continue;
		}
		if(str.length != 2) {
			str += ", \n";
		}
		str += s + k + " : " + js_Boot.__string_rec(o[k],s);
		}
		s = s.substring(1);
		str += "\n" + s + "}";
		return str;
	case "string":
		return o;
	default:
		return String(o);
	}
};
js_Boot.__nativeClassName = function(o) {
	var name = js_Boot.__toStr.call(o).slice(8,-1);
	if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
		return null;
	}
	return name;
};
js_Boot.__resolveNativeClass = function(name) {
	return $global[name];
};
var js_Browser = function() { };
js_Browser.__name__ = "js.Browser";
js_Browser.createXMLHttpRequest = function() {
	if(typeof XMLHttpRequest != "undefined") {
		return new XMLHttpRequest();
	}
	if(typeof ActiveXObject != "undefined") {
		return new ActiveXObject("Microsoft.XMLHTTP");
	}
	throw haxe_Exception.thrown("Unable to create XMLHttpRequest object.");
};
var me_cunity_debug_DebugOutput = $hxEnums["me.cunity.debug.DebugOutput"] = { __ename__ : true, __constructs__ : ["CONSOLE","HAXE","NATIVE"]
	,CONSOLE: {_hx_index:0,__enum__:"me.cunity.debug.DebugOutput",toString:$estr}
	,HAXE: {_hx_index:1,__enum__:"me.cunity.debug.DebugOutput",toString:$estr}
	,NATIVE: {_hx_index:2,__enum__:"me.cunity.debug.DebugOutput",toString:$estr}
};
var me_cunity_debug_Out = $hx_exports["Out"] = function() { };
me_cunity_debug_Out.__name__ = "me.cunity.debug.Out";
me_cunity_debug_Out._trace = function(v,i) {
	if(me_cunity_debug_Out.suspended) {
		return;
	}
	var warned = false;
	if(i != null && Object.prototype.hasOwnProperty.call(i,"customParams")) {
		i = i.customParams[0];
	}
	var msg = i != null ? i.fileName + ":" + i.methodName + ":" + i.lineNumber + ":" : "";
	msg += Std.string(v);
	switch(me_cunity_debug_Out.traceTarget._hx_index) {
	case 0:
		debug(msg);
		break;
	case 1:
		var msg1 = i != null ? i.fileName + ":" + i.lineNumber + ":" + i.methodName + ":" : "";
		msg1 += Std.string(v) + "<br/>";
		var d = window.document.getElementById("haxe:trace");
		if(d == null && !warned) {
			warned = true;
			alert("No haxe:trace element defined\n" + msg1);
		} else {
			d.innerHTML += msg1;
		}
		break;
	case 2:
		console.log(msg);
		break;
	}
};
me_cunity_debug_Out.log2 = function(v,i) {
	var msg = i != null ? i.fileName + ":" + i.lineNumber + ":" + i.methodName + ":" : "";
	msg += Std.string(v);
	var http = new haxe_http_HttpJs("http://localhost/devel/php/jsLog.php");
	http.setParameter("log",msg);
	http.async = true;
	http.onData = function(data) {
		if(data != "OK") {
			haxe_Log.trace(data,{ fileName : "me/cunity/debug/Out.hx", lineNumber : 207, className : "me.cunity.debug.Out", methodName : "log2"});
		}
	};
	http.request(true);
};
me_cunity_debug_Out.dumpObjectRSafe = function(root,recursive,i) {
	if(recursive == null) {
		recursive = false;
	}
	var oCopy = { };
	var _g = 0;
	var _g1 = Reflect.fields(root);
	while(_g < _g1.length) {
		var f = _g1[_g];
		++_g;
		if(f == "parentView") {
			oCopy.parentView = root.parentView.instancePath;
			continue;
		}
		oCopy[f] = Reflect.field(root,f);
	}
	me_cunity_debug_Out.dumpObject(oCopy,i);
};
me_cunity_debug_Out.dumpObjectTree = $hx_exports["me"]["cunity"]["debug"]["Out"]["dumpObjectTree"] = function(root,recursive,i) {
	if(recursive == null) {
		recursive = false;
	}
	me_cunity_debug_Out.dumpedObjects = [];
	me_cunity_debug_Out._dumpObjectTree(root,Type.typeof(root),recursive,i);
};
me_cunity_debug_Out._dumpObjectTree = function(root,parent,recursive,i) {
	var m;
	if(js_Boot.getClass(root) != null) {
		var c = js_Boot.getClass(root);
		m = c.__name__;
	} else {
		var e = Type.typeof(root);
		m = $hxEnums[e.__enum__].__constructs__[e._hx_index];
	}
	var fields = js_Boot.getClass(root) != null ? Type.getInstanceFields(js_Boot.getClass(root)) : Reflect.fields(root);
	if(m == "String") {
		me_cunity_debug_Out._trace(Std.string(root) + " len:" + Std.string(root.length),i);
	} else {
		me_cunity_debug_Out.dumpedObjects.push(root);
		me_cunity_debug_Out._trace(m + " fields:" + fields.length + ":" + fields.slice(0,5).toString(),i);
	}
	try {
		var _g = 0;
		while(_g < fields.length) {
			var f = fields[_g];
			++_g;
			haxe_Log.trace(f,{ fileName : "me/cunity/debug/Out.hx", lineNumber : 313, className : "me.cunity.debug.Out", methodName : "_dumpObjectTree", customParams : [i]});
			if(recursive) {
				if(me_cunity_debug_Out.dumpedObjects.length > 1000) {
					me_cunity_debug_Out._trace(me_cunity_debug_Out.dumpedObjects.toString(),i);
					throw haxe_Exception.thrown("oops");
				} else {
					var _o = root[f];
					if(!Lambda.has(me_cunity_debug_Out.dumpedObjects,_o)) {
						me_cunity_debug_Out._dumpObjectTree(_o,Type.typeof(_o),true,i);
					}
				}
			}
		}
	} catch( _g ) {
		var ex = haxe_Exception.caught(_g).unwrap();
		haxe_Log.trace(ex,{ fileName : "me/cunity/debug/Out.hx", lineNumber : 337, className : "me.cunity.debug.Out", methodName : "_dumpObjectTree"});
	}
};
me_cunity_debug_Out.dumpObject = function(ob,i) {
	var tClass = js_Boot.getClass(ob);
	var m = "dumpObject:" + Std.string(ob != null ? js_Boot.getClass(ob) : ob) + "\n";
	var names = [];
	names = js_Boot.getClass(ob) != null ? Type.getInstanceFields(js_Boot.getClass(ob)) : Reflect.fields(ob);
	if(js_Boot.getClass(ob) != null) {
		var c = js_Boot.getClass(ob);
		m = c.__name__ + ":\n";
	}
	var _g = 0;
	while(_g < names.length) {
		var name = names[_g];
		++_g;
		if(Lambda.has(me_cunity_debug_Out.skipFields,name)) {
			m += "" + name + ":skipped\n";
			continue;
		}
		try {
			var t = Std.string(Type.typeof(Reflect.field(ob,name)));
			var tmp = me_cunity_debug_Out.skipFunctions && t == "TFunction";
			m += name + ":" + Std.string(Reflect.field(ob,name)) + ":" + t + "\n";
		} catch( _g1 ) {
			var ex = haxe_Exception.caught(_g1).unwrap();
			m += name + ":" + Std.string(ex);
		}
	}
	me_cunity_debug_Out._trace(m,i);
};
me_cunity_debug_Out.dumpStack = function(sA,i) {
	var b = new StringBuf();
	b.b += Std.string("StackDump:" + "\n");
	var _g = 0;
	while(_g < sA.length) {
		var item = sA[_g];
		++_g;
		me_cunity_debug_Out.itemToString(item,b);
		b.b += "\n";
	}
	haxe_Log.trace(b.b,{ fileName : "me/cunity/debug/Out.hx", lineNumber : 405, className : "me.cunity.debug.Out", methodName : "dumpStack", customParams : [i]});
};
me_cunity_debug_Out.itemToString = function(s,b) {
	switch(s._hx_index) {
	case 0:
		b.b += "a C function";
		break;
	case 1:
		var m = s.m;
		b.b += "module ";
		b.b += m == null ? "null" : "" + m;
		break;
	case 2:
		var _g = s.column;
		var line = s.line;
		var file = s.file;
		var s1 = s.s;
		if(s1 != null) {
			me_cunity_debug_Out.itemToString(s1,b);
			b.b += " (";
		}
		b.b += file == null ? "null" : "" + file;
		b.b += " line ";
		b.b += line == null ? "null" : "" + line;
		if(s1 != null) {
			b.b += ")\n";
		}
		break;
	case 3:
		var meth = s.method;
		var cname = s.classname;
		b.b += cname == null ? "null" : "" + cname;
		b.b += ".";
		b.b += meth == null ? "null" : "" + meth;
		b.b += "\n";
		break;
	case 4:
		var v = s.v;
		b.b += Std.string("LocalFunction:" + v);
		break;
	}
};
me_cunity_debug_Out.fTrace = function(str,arr,i) {
	var str_arr = str.split(" @");
	var str_buf_b = "";
	var _g = 0;
	var _g1 = str_arr.length;
	while(_g < _g1) {
		var i1 = _g++;
		str_buf_b += Std.string(str_arr[i1]);
		if(arr[i1] != null) {
			str_buf_b += Std.string(arr[i1]);
		}
	}
	me_cunity_debug_Out._trace(str_buf_b,i);
};
var react_ReactComponent = function() { };
react_ReactComponent.__name__ = "react.ReactComponent";
var ReactDOM = require("react-dom");
var react_ReactType = {};
react_ReactType.fromString = function(s) {
	return s;
};
react_ReactType.fromFunction = function(f) {
	return f;
};
react_ReactType.fromFunctionWithProps = function(f) {
	return f;
};
react_ReactType.fromComp = function(cls) {
	if(cls.__jsxStatic != null) {
		return cls.__jsxStatic;
	}
	return cls;
};
var react_ReactTypeOf = {};
react_ReactTypeOf._new = function(node) {
	var this1 = node;
	return this1;
};
react_ReactTypeOf.fromFunctionWithProps = function(f) {
	var this1 = react_ReactType.fromFunctionWithProps(f);
	return this1;
};
react_ReactTypeOf.fromComp = function(cls) {
	var this1 = react_ReactType.fromComp(cls);
	return this1;
};
react_ReactTypeOf.fromFunctionWithoutProps = function(f) {
	var this1 = react_ReactType.fromFunction(f);
	return this1;
};
react_ReactTypeOf.fromCompWithoutProps = function(cls) {
	var this1 = react_ReactType.fromComp(cls);
	return this1;
};
var react_apollo_ApolloProvider = require("react-apollo").ApolloProvider;
var src_DefaultClient = function(uri) {
	apollo_client_ApolloClient.call(this,{ queryDeduplication : false, link : apollo_link_http_HttpLink({ uri : uri, credentials : "include", headers : { "Content-Type" : "application/json"}, fetchOptions : { credentials : "include", method : "POST"}}), cache : new apollo_cache_inmemory_InMemoryCache()});
};
src_DefaultClient.__name__ = "src.DefaultClient";
src_DefaultClient.__super__ = apollo_client_ApolloClient;
src_DefaultClient.prototype = $extend(apollo_client_ApolloClient.prototype,{
	__class__: src_DefaultClient
});
var src_Go = function() { };
src_Go.__name__ = "src.Go";
src_Go.main = function() {
	haxe_Log.trace = me_cunity_debug_Out._trace;
	haxe_Log.trace("Hi",{ fileName : "src/Go.hx", lineNumber : 21, className : "src.Go", methodName : "main"});
	var client = new src_DefaultClient("http://localhost:888/graphql");
	haxe_Log.trace(src_Go.allMandQuery,{ fileName : "src/Go.hx", lineNumber : 30, className : "src.Go", methodName : "main"});
	haxe_Log.trace(src_Go.allMandQuery.definitions[0],{ fileName : "src/Go.hx", lineNumber : 31, className : "src.Go", methodName : "main"});
	var ss = Reflect.field(src_Go.allMandQuery.definitions[0],"selectionSet");
	haxe_Log.trace(ss.selections[0].selectionSet.selections[0],{ fileName : "src/Go.hx", lineNumber : 33, className : "src.Go", methodName : "main"});
	client.query({ query : src_Go.allMandQuery, fetchResults : true}).then(function(result) {
		haxe_Log.trace(result,{ fileName : "src/Go.hx", lineNumber : 36, className : "src.Go", methodName : "main"});
	},function(error) {
		haxe_Log.trace(error,{ fileName : "src/Go.hx", lineNumber : 38, className : "src.Go", methodName : "main"});
	});
	client.query({ query : src_Go.allEndReasons, fetchResults : true}).then(function(result) {
		haxe_Log.trace(result,{ fileName : "src/Go.hx", lineNumber : 42, className : "src.Go", methodName : "main"});
	},function(error) {
		haxe_Log.trace(error,{ fileName : "src/Go.hx", lineNumber : 45, className : "src.Go", methodName : "main"});
	});
	src_Go.render(src_Go.createRoot(),client);
};
src_Go.createRoot = function() {
	var root = window.document.createElement("div");
	root.className = "rootBox";
	window.document.body.appendChild(root);
	return root;
};
src_Go.render = function(root,client) {
	var app = ReactDOM.render({ "$$typeof" : $$tre, type : react_ReactType.fromComp(react_apollo_ApolloProvider), props : { client : client, children : "666"}, key : null, ref : null},root);
	haxe_Log.trace("GO",{ fileName : "src/Go.hx", lineNumber : 68, className : "src.Go", methodName : "render"});
};
var tink_core_Noise = $hxEnums["tink.core.Noise"] = { __ename__ : true, __constructs__ : ["Noise"]
	,Noise: {_hx_index:0,__enum__:"tink.core.Noise",toString:$estr}
};
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
String.prototype.__class__ = String;
String.__name__ = "String";
Array.__name__ = "Array";
js_Boot.__toStr = ({ }).toString;
var $$tre = (typeof Symbol === "function" && Symbol.for && Symbol.for("react.element")) || 0xeac7;
graphql_parser_GeneratedParser.ValidDirectiveLocations = (function($this) {
	var $r;
	var _g = new haxe_ds_StringMap();
	_g.h["QUERY"] = true;
	_g.h["MUTATION"] = true;
	_g.h["SUBSCRIPTION"] = true;
	_g.h["FIELD"] = true;
	_g.h["FRAGMENT_DEFINITION"] = true;
	_g.h["FRAGMENT_SPREAD"] = true;
	_g.h["INLINE_FRAGMENT"] = true;
	_g.h["SCHEMA"] = true;
	_g.h["SCALAR"] = true;
	_g.h["OBJECT"] = true;
	_g.h["FIELD_DEFINITION"] = true;
	_g.h["ARGUMENT_DEFINITION"] = true;
	_g.h["INTERFACE"] = true;
	_g.h["UNION"] = true;
	_g.h["ENUM"] = true;
	_g.h["ENUM_VALUE"] = true;
	_g.h["INPUT_OBJECT"] = true;
	_g.h["INPUT_FIELD_DEFINITION"] = true;
	$r = _g;
	return $r;
}(this));
graphql_parser_StringSlice.CHARS = (function($this) {
	var $r;
	var _g = [];
	{
		var _g1 = 0;
		while(_g1 < 128) {
			var i = _g1++;
			_g.push(new graphql_parser__$StringSlice_Data(String.fromCodePoint(i),0,1));
		}
	}
	$r = _g;
	return $r;
}(this));
graphql_parser_StringSlice.EMPTY = new graphql_parser__$StringSlice_Data("",0,0);
me_cunity_debug_Out.suspended = false;
me_cunity_debug_Out.skipFields = [];
me_cunity_debug_Out.skipFunctions = true;
me_cunity_debug_Out.traceToConsole = false;
me_cunity_debug_Out.traceTarget = me_cunity_debug_DebugOutput.NATIVE;
me_cunity_debug_Out.aStack = haxe_CallStack.callStack;
src_Go.allMandQuery = { definitions : [{ name : null, variableDefinitions : [], selectionSet : { selections : [{ name : { kind : "Name", loc : null, value : "allMandators"}, alias : null, selectionSet : { selections : [{ name : { kind : "Name", loc : null, value : "totalCount"}, alias : null, selectionSet : null, kind : "Field", loc : null, directives : [], 'arguments' : []}], kind : "SelectionSet", loc : null}, kind : "Field", loc : null, directives : [], 'arguments' : []}], kind : "SelectionSet", loc : null}, kind : "OperationDefinition", operation : "query", loc : null, directives : []}], kind : "Document", loc : null};
src_Go.allEndReasons = { definitions : [{ name : null, variableDefinitions : [], selectionSet : { selections : [{ name : { kind : "Name", loc : null, value : "allEndReasons"}, alias : null, selectionSet : { selections : [{ name : { kind : "Name", loc : null, value : "edges"}, alias : null, selectionSet : { selections : [{ name : { kind : "Name", loc : null, value : "node"}, alias : null, selectionSet : { selections : [{ name : { kind : "Name", loc : null, value : "id"}, alias : null, selectionSet : null, kind : "Field", loc : null, directives : [], 'arguments' : []},{ name : { kind : "Name", loc : null, value : "reason"}, alias : null, selectionSet : null, kind : "Field", loc : null, directives : [], 'arguments' : []},{ name : { kind : "Name", loc : null, value : "mandator"}, alias : null, selectionSet : null, kind : "Field", loc : null, directives : [], 'arguments' : []}], kind : "SelectionSet", loc : null}, kind : "Field", loc : null, directives : [], 'arguments' : []}], kind : "SelectionSet", loc : null}, kind : "Field", loc : null, directives : [], 'arguments' : []}], kind : "SelectionSet", loc : null}, kind : "Field", loc : null, directives : [], 'arguments' : []}], kind : "SelectionSet", loc : null}, kind : "OperationDefinition", operation : "query", loc : null, directives : []}], kind : "Document", loc : null};
src_Go.main();
})(typeof exports != "undefined" ? exports : typeof window != "undefined" ? window : typeof self != "undefined" ? self : this, typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
